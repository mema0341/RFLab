
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>HW4_script</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-10-05"><meta name="DC.source" content="HW4_script.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">HW4</a></li><li><a href="#2">Define necessary variables</a></li><li><a href="#3">1) Determine the name of the full broadcast ephemeris file (Rinex V2) for September 1, 2020.</a></li><li><a href="#4">2) Use the function read_clean_GPSbroadcast.m (or a similar function you find elsewhere or write</a></li><li><a href="#5">3) Write a function broadcast_eph2pos to compute the position of a GPS satellite based on the ephemeris data, for</a></li><li><a href="#6">4) Choose one or two satellites (PRN&#8217;s) to study in detail. Using the broadcast2pos function (or similar code</a></li><li><a href="#7">5) Using the compute_azelrange function you wrote in HW3, find the range, azimuth, and elevation from</a></li><li><a href="#8">6) Now recompute the range accounting for the signal travel time and coordinate frame rotation as described in the</a></li><li><a href="#9">7. Download the NIST rinex observation file for September 1, 2020. Use the function read_rinex_obs8 or</a></li><li><a href="#10">Plot C1 and P2 for PRN1</a></li><li><a href="#11">Grab C1 and P2 for PRN1 and Plot</a></li><li><a href="#12">8) Describe the visibility results for the three locations.</a></li><li><a href="#13">Functions</a></li></ul></div><h2 id="1">HW4</h2><pre class="codeinput">clc;clear;close <span class="string">all</span>;

<span class="comment">% Date = October 5, 2020</span>
</pre><h2 id="2">Define necessary variables</h2><pre class="codeinput">c   = 2.99792458e8;    <span class="comment">% GPS acceptd speed of light, m/s</span>
</pre><h2 id="3">1) Determine the name of the full broadcast ephemeris file (Rinex V2) for September 1, 2020.</h2><p>fname = "brdc2450.20n";</p><pre class="codeinput">fname = <span class="string">"nist2450.20n"</span>; <span class="comment">%Either the broadcast data from NIST or brdc work.</span>
</pre><h2 id="4">2) Use the function read_clean_GPSbroadcast.m (or a similar function you find elsewhere or write</h2><p>yourself) to load the ephemeris data into a numerical array.</p><pre class="codeinput">seconds_in_day = 60*60*24;
tow = seconds_in_day * 2; <span class="comment">% Because we are on Tuesday</span>

[gps_ephem,ionoparams] = read_clean_GPSbroadcast(fname,true);
</pre><h2 id="5">3) Write a function broadcast_eph2pos to compute the position of a GPS satellite based on the ephemeris data, for</h2><p>a specified set of times.</p><pre class="codeinput">t = [0:1:24*60*2]*30+172800;  <span class="comment">%Time of week in seconds with 30 sec spacing</span>
<span class="comment">% t = [0:1:24*60]*60+172800;  %Time of week in seconds with 30 sec spacing</span>
WN = 2121*ones(size(t)); <span class="comment">% WN = 73*ones(size(t));</span>
T_in = [WN;t].';            <span class="comment">%[nx2]</span>
gpsposcheck = zeros(32,3);

PRN = gps_ephem(:,1); <span class="comment">% Grab all the prn values from the ephemeris file</span>
num_sat = length(PRN); <span class="comment">% Obtain the number of satellites we're interested in</span>

<span class="comment">% Grab the position of all of the satellites in the ephemeris file</span>
<span class="keyword">for</span> kk = 1:num_sat
    <span class="comment">% Use our broadcast_eph2pos file to grab the position of the satellite</span>
    [health,pos] = broadcast_eph2pos(gps_ephem,T_in,PRN(kk));
    POS_ecef(:,:,kk) = pos/1000;     <span class="comment">%n x 3 x num_sat</span>

    <span class="comment">% This is to compare to the gpspos text file!</span>
    <span class="keyword">if</span> kk &lt;= 30
        gpsposcheck(kk,:) = POS_ecef(1,:,kk);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="6">4) Choose one or two satellites (PRN&#8217;s) to study in detail. Using the broadcast2pos function (or similar code</h2><p>you wrote yourself) from HW3, plot the ECEF coordinates computed based on the almanac for these satellites at an interval of 30 seconds over the entire day. On the x-axis show the time in hours of the day (0-24 hours). On the same graph, plot the ECEF coordinates computed using your new broadcast_eph2pos function for the same times. Compare and discuss the results, using a plot of the differences between them, if that is helpful.</p><pre class="codeinput">prn_sat1 = 1; <span class="comment">% I picked PRNs 1 and 2</span>
prn_sat2 = 2;

<span class="comment">% First we filter out the PRNs we want from our ephemeris data</span>
ephem_PRN1 = find(PRN==prn_sat1);
ephem_PRN2 = find(PRN==prn_sat2);

ephem_PRN1_pos = POS_ecef(:,:,ephem_PRN1); <span class="comment">% Now we can plot the ephemeris positions for satellites with PRN1</span>
ephem_PRN2_pos = POS_ecef(:,:,ephem_PRN2); <span class="comment">% Now we can plot the ephemeris positions for satellites with PRN2</span>

<span class="comment">% Now we grab the positions using YUMA file</span>
[alm,alm_cellarray] = read_GPSyuma(<span class="string">'Data/YUMA245.alm'</span>,2);
yuma_PRN = alm(:,1);
yuma_num_sat = length(PRN);
<span class="keyword">for</span> kk = 1:num_sat
    [yuma_health,yuma_pos] = broadcast2pos(alm,T_in,PRN(kk));
    yumaPOS_ecef(:,:,kk) = yuma_pos/1000;     <span class="comment">%n x 3 x num_sat</span>
<span class="keyword">end</span>

yuma_PRN1 = find(yuma_PRN==prn_sat1);
yuma_PRN2 = find(yuma_PRN==prn_sat2);

yuma_PRN1_pos = yumaPOS_ecef(:,:,yuma_PRN1); <span class="comment">% Now we can plot the yuma positions for satellites with PRN1</span>
yuma_PRN2_pos = yumaPOS_ecef(:,:,yuma_PRN2); <span class="comment">% Now we can plot the yuma positions for satellites with PRN2</span>

<span class="comment">% Now we do our plots... let's just play with the first PRN1 position</span>
time = [0:1:24*60*2]*30/3600;  <span class="comment">%Time of week in seconds with 30 sec spacing</span>
time = time';

figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, squeeze(ephem_PRN1_pos(:,1,1)), <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 1st ecef coord</span>
plot(time, squeeze(ephem_PRN1_pos(:,2,1)), <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 2nd ecef coord</span>
plot(time, squeeze(ephem_PRN1_pos(:,3,1)), <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 3rd ecef coord</span>
plot(time, yuma_PRN1_pos(:,1), <span class="string">'Linestyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 1st ecef coord</span>
plot(time, yuma_PRN1_pos(:,2), <span class="string">'Linestyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 2nd ecef coord</span>
plot(time, yuma_PRN1_pos(:,3), <span class="string">'Linestyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 3rd ecef coord</span>
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Coordinate [km]'</span>)
legend({<span class="string">'Ephemeris Coord 1'</span>, <span class="string">'Ephemeris Coord 2'</span>, <span class="string">'Ephemeris Coord 3'</span>, <span class="string">'YUMA Coord 1'</span>, <span class="string">'YUMA Coord 2'</span>, <span class="string">'YUMA Coord 3'</span>}, <span class="string">'Location'</span>,<span class="string">'southwest'</span>)
title({[<span class="string">'ECEF Coords PRN1'</span>], [<span class="string">'Yuma and Ephemeris Comparison'</span>]})

figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, squeeze(ephem_PRN2_pos(:,1,1)), <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 1st ecef coord</span>
plot(time, squeeze(ephem_PRN2_pos(:,2,1)), <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 2nd ecef coord</span>
plot(time, squeeze(ephem_PRN2_pos(:,3,1)), <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 3rd ecef coord</span>
plot(time, yuma_PRN2_pos(:,1), <span class="string">'Linestyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 1st ecef coord</span>
plot(time, yuma_PRN2_pos(:,2), <span class="string">'Linestyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 2nd ecef coord</span>
plot(time, yuma_PRN2_pos(:,3), <span class="string">'Linestyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2) <span class="comment">% Plot 3rd ecef coord</span>
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Coordinate [km]'</span>)
legend({<span class="string">'Ephemeris Coord 1'</span>, <span class="string">'Ephemeris Coord 2'</span>, <span class="string">'Ephemeris Coord 3'</span>, <span class="string">'YUMA Coord 1'</span>, <span class="string">'YUMA Coord 2'</span>, <span class="string">'YUMA Coord 3'</span>}, <span class="string">'Location'</span>,<span class="string">'southwest'</span>)
title({[<span class="string">'ECEF Coords PRN2'</span>], [<span class="string">'Yuma and Ephemeris Comparison'</span>]})

<span class="comment">% Now we do diff plots of PRN1 because that maeks more sense to me</span>
diff1 = reshape(ephem_PRN1_pos(:,1,:) - yuma_PRN1_pos(:,1), [length(t), length(ephem_PRN1)]);
diff2 = reshape(ephem_PRN1_pos(:,2,:) - yuma_PRN1_pos(:,2), [length(t), length(ephem_PRN1)]);
diff3 = reshape(ephem_PRN1_pos(:,3,:) - yuma_PRN1_pos(:,3), [length(t), length(ephem_PRN1)]);

f=figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, diff1(:,1), <span class="string">'LineWidth'</span>, 2)
plot(time, diff2(:,1), <span class="string">'LineWidth'</span>, 2)
plot(time, diff3(:,1), <span class="string">'LineWidth'</span>, 2)
title({[<span class="string">'Difference Between ECEF Coords [km]'</span>],[<span class="string">'PRN1'</span>]})
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Difference [km]'</span>)
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Difference [km]'</span>)
legend({<span class="string">'ECEF Coord 1'</span>, <span class="string">'ECEF Coord 2'</span>, <span class="string">'ECEF Coord 3'</span>},<span class="string">'Location'</span>,<span class="string">'northwest'</span>)

<span class="comment">% Now we do diff plots of PRN2</span>
diff1 = reshape(ephem_PRN2_pos(:,1,:) - yuma_PRN2_pos(:,1), [length(t), length(ephem_PRN2)]);
diff2 = reshape(ephem_PRN2_pos(:,2,:) - yuma_PRN2_pos(:,2), [length(t), length(ephem_PRN2)]);
diff3 = reshape(ephem_PRN2_pos(:,3,:) - yuma_PRN2_pos(:,3), [length(t), length(ephem_PRN2)]);

f=figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, diff1(:,1), <span class="string">'LineWidth'</span>, 2)
plot(time, diff2(:,1), <span class="string">'LineWidth'</span>, 2)
plot(time, diff3(:,1), <span class="string">'LineWidth'</span>, 2)
title({[<span class="string">'Difference Between ECEF Coords [km]'</span>],[<span class="string">'PRN2'</span>]})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Difference [km]'</span>)
legend({<span class="string">'ECEF Coord 1'</span>, <span class="string">'ECEF Coord 2'</span>, <span class="string">'ECEF Coord 3'</span>},<span class="string">'Location'</span>,<span class="string">'northeast'</span>)
</pre><img vspace="5" hspace="5" src="HW4_script_01.png" alt=""> <img vspace="5" hspace="5" src="HW4_script_02.png" alt=""> <img vspace="5" hspace="5" src="HW4_script_03.png" alt=""> <img vspace="5" hspace="5" src="HW4_script_04.png" alt=""> <h2 id="7">5) Using the compute_azelrange function you wrote in HW3, find the range, azimuth, and elevation from</h2><p>your satellite(s) to the NIST IGS Site for the entire day. Use the GPS positions you calculated using your new function based on the ephemeris, not the almanac. Plot each of these versus time in hours of the day.</p><pre class="codeinput">NIST_ecef = [-1288398 -4721697 4078625]; <span class="comment">%ECEF coordinates in meters x y z</span>
nistECEF = [NIST_ecef];
num_NIST_ecef = size(nistECEF,1);    <span class="comment">%number of NIST_ecef locations</span>

num_time = size(t,2);
<span class="keyword">for</span> kk = 1:2
    [health,pos] = broadcast_eph2pos(gps_ephem,T_in,kk);
    <span class="keyword">for</span> tt = 1:num_time
        [azt(tt,kk,1),elt(tt,kk,1),ranget(tt,kk,1)] = compute_azelrange(NIST_ecef,pos(tt,:));
    <span class="keyword">end</span>
    <span class="keyword">if</span> kk == 1
        satPos1 = pos;
    <span class="keyword">else</span>
        satPos2 = pos;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Plot Azimuth for Problem 5</span>
f=figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, azt(:,ephem_PRN1(1)), <span class="string">'LineWidth'</span>, 2)
plot(time, azt(:,ephem_PRN2(1)), <span class="string">'LineWidth'</span>, 2)
title({[<span class="string">'Azimuth [Degrees]'</span>]})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Azimuth [Degrees]'</span>)
legend({<span class="string">'PRN1'</span>, <span class="string">'PRN2'</span>})

<span class="comment">% Plot Elevation for Problem 5</span>
f=figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, elt(:,1), <span class="string">'LineWidth'</span>, 2)
plot(time, elt(:,2), <span class="string">'LineWidth'</span>, 2)
title({[<span class="string">'Elevation [Degrees]'</span>]})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Elevation [Degrees]'</span>)
legend({<span class="string">'PRN1'</span>, <span class="string">'PRN2'</span>})

<span class="comment">% Plot Range for Problem 5</span>
f=figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(time, ranget(:,1), <span class="string">'LineWidth'</span>, 2)
plot(time, ranget(:,2), <span class="string">'LineWidth'</span>, 2)
title({[<span class="string">'Range [Meters]'</span>]})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Range [Meters]'</span>)
legend({<span class="string">'PRN1'</span>, <span class="string">'PRN2'</span>})
</pre><img vspace="5" hspace="5" src="HW4_script_05.png" alt=""> <img vspace="5" hspace="5" src="HW4_script_06.png" alt=""> <img vspace="5" hspace="5" src="HW4_script_07.png" alt=""> <h2 id="8">6) Now recompute the range accounting for the signal travel time and coordinate frame rotation as described in the</h2><p>attachment. Add this updated range to the previous range plot and compare the results. What is the largest difference you found?</p><pre class="codeinput"><span class="comment">% COMPUTING THE EXPECTED RANGE:</span>
<span class="comment">% The expected range of interest is the distance between the position of the GPS satellite at the time of transmission</span>
<span class="comment">% (Tt) and the GPS receiving antenna at the time of reception (Tr). To compute this distance, both positions must be</span>
<span class="comment">% represented in the same coordinate frame - we use the ECEF coordinate frame at the time of reception (Tr).</span>
satECEF = satPos1; <span class="comment">% We'll do this for just one sattelite</span>

TOL = 1e-8;

not_converged = true;

satECEF = satPos1;
<span class="comment">% Choose one satellite</span>
<span class="keyword">while</span> not_converged
    <span class="comment">% 1) Compute the GPS satellite poisition in ECEF at Tr based on the</span>
    <span class="comment">% broadcast ephemeris</span>

    <span class="comment">% Compute GPS satellite position at recieved time for rough idea of range</span>
    <span class="comment">% to satellite using an assumed location of reciever</span>
    Tr = ranget(:,1) / c; <span class="comment">% Calc for first satellite</span>

    <span class="comment">% 2) Use an a priori value for the receiver coordinates (RX) to find geometric range R = |rGPS &#8211; rRX|</span>
    <span class="keyword">for</span> tt = 1:num_time
        [~, ~, rGPS] = ECEF2llh(satECEF(tt,:));
        [~, ~,  rRx] = ECEF2llh(nistECEF); <span class="comment">% assumed location of reciever is location for NIST</span>
        R(tt) = abs(rGPS - rRx);

    <span class="keyword">end</span>
    <span class="comment">% 3) Compute the time of transmission: Tt = Tr &#8211; R/c (use the real speed of</span>
    <span class="comment">% light, NOT 3e8), it's usually 70-100 milliseconds</span>
    Tt = Tr  - R'/c;

    <span class="comment">% 4) Compute the satellite position at Tt in ECEF at Tt based on the broadcast ephemeris.</span>
    newt = Tt*30+172800;  <span class="comment">%Time of week in seconds with 30 sec spacing</span>
    newT_in = [WN;newt'].';
    [health, new_pos] = broadcast_eph2pos(gps_ephem, newT_in, PRN);

    <span class="comment">% 5) Rotate the satellite position to ECEF at Tr. (wE is the rotation rate of the Earth)</span>
    w_e = 7.2921151467e-5; <span class="comment">% earth rotation rate [rad / sec]</span>
    <span class="keyword">for</span> kk = 1
        <span class="keyword">for</span> tt = 1:num_time

            phi = w_e * (Tr(tt, kk)-Tt(tt, kk)); <span class="comment">% amount of rotation the earth moved during time of transmission</span>
            cosPhi = cos(phi);
            sinPhi = sin(phi);

            rotation_matrix = [cosPhi, sinPhi, 0; -sinPhi, cosPhi, 0; 0, 0, 1];
            rot_pos(tt ,: , kk) = (rotation_matrix * new_pos(tt,:).')';

        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% 6) Compute a new geometric range using this position for rGPS, R = |rGPS &#8211; rRX|</span>
    <span class="keyword">for</span> jj = 1:num_NIST_ecef
        NIST_ecef = nistECEF(jj,:);      <span class="comment">%grab the appropriate NIST_ecef location</span>
        num_time = size(t,2);
        <span class="keyword">for</span> kk = 1
            <span class="keyword">for</span> tt = 1:num_time
                satECEF = rot_pos(tt,:,kk);
                [~,~,new_ranget(tt,kk,jj)] = compute_azelrange(NIST_ecef,satECEF);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% 7) Repeat steps 3-6 until convergence. (If it takes more than two iterations, something is wrong).</span>
    sprintf(<span class="string">'Tolerance: %0.5g'</span>,abs(new_ranget(1,1) - ranget(1,1)))
    <span class="keyword">if</span> abs(ranget(1,1) - new_ranget(1,1)) &lt; TOL
        not_converged = false; <span class="comment">% Go back to beginning :)</span>
    <span class="keyword">end</span>
    ranget = new_ranget;

<span class="keyword">end</span>

<span class="comment">% Plot Range</span>
figure
hold <span class="string">on</span>; grid <span class="string">on</span>;
plot(time, ranget)
title({[<span class="string">'Problem 6 Range [Meters]'</span>]})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Range [Meters]'</span>)
legend({<span class="string">'PRN1'</span>, <span class="string">'PRN2'</span>})
</pre><pre class="codeoutput">
ans =

    'Tolerance: 2.2153e+06'

</pre><pre class="codeoutput error">Index in position 1 exceeds array bounds (must not exceed 1).

Error in HW4_script (line 221)
        [~, ~, rGPS] = ECEF2llh(satECEF(tt,:));
</pre><h2 id="9">7. Download the NIST rinex observation file for September 1, 2020. Use the function read_rinex_obs8 or</h2><p>another version that you find or write yourself to read the RINEX file and extract all of the measured C1 and P2 pseudoranges for the satellite you chose. Plot these pseudoranges versus time in hours of the day.</p><pre class="codeinput">fname = <span class="string">"DATA\nist2450.20o"</span>;

prn1_rdata = read_rinex_obs8(fname, [1]); <span class="comment">% Grab PRN1 data</span>
prn2_rdata = read_rinex_obs8(fname, [2]); <span class="comment">% Grab PRN2 data</span>

<span class="comment">% Grab C1 and P2 for PRN1 and Plot</span>
prn1_C1 = prn1_rdata.data(:,4);
prn1_P2 = prn1_rdata.data(:,8);
</pre><h2 id="10">Plot C1 and P2 for PRN1</h2><pre class="codeinput">figure; hold <span class="string">on</span>; grid <span class="string">on</span> <span class="comment">% Create figure</span>
plot(1:1:length(prn1_C1), prn1_C1, <span class="string">'LineWidth'</span>, 2)
plot(1:1:length(prn1_P2), prn1_P2, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2)
<span class="comment">% Make plot pretty</span>
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Pseudoranges [km]'</span>)
legend({<span class="string">'C1'</span>, <span class="string">'P2'</span>})
title({[<span class="string">'Pseudoranges C1 and P2'</span>], [<span class="string">'PRN1'</span>]})
</pre><h2 id="11">Grab C1 and P2 for PRN1 and Plot</h2><pre class="codeinput">prn2_C1 = prn2_rdata.data(:,4);
prn2_P2 = prn1_rdata.data(:,8);

<span class="comment">% Plot C1 and P2 for PRN2</span>
figure; hold <span class="string">on</span>; grid <span class="string">on</span>
plot(1:1:length(prn2_C1), prn2_C1, <span class="string">'LineWidth'</span>, 2)
plot(1:1:length(prn2_P2), prn2_P2, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 2)
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel(<span class="string">'Time [hours]'</span>)
ylabel(<span class="string">'Pseudoranges [m]'</span>)
legend({<span class="string">'C1'</span>, <span class="string">'P2'</span>})
title({[<span class="string">'Pseudoranges C1 and P2'</span>], [<span class="string">'PRN2'</span>]})
</pre><h2 id="12">8) Describe the visibility results for the three locations.</h2><p>Compare the measured pseudoranges to your predicted range. Briefly explain what might be the source of any differences between them. (To do this part, create a time vector from the observations and compute the predicted range for those times.) The range calculated in problem 6 has the same order of magnitude as the pseudoranges. This could be becausse sp3 files are re-calculated every epoch and it takes a much longer time to calculate these but they are more accurate.</p><h2 id="13">Functions</h2><p>Problem 1 function</p><pre class="codeinput"><span class="keyword">function</span> [lat,lon,h] = ECEF2llh(xyz)
R = 6378.137e3;             <span class="comment">%SemiMajor axis of ellipsoid (meters)</span>
f = 1/298.257223563;<span class="comment">% flattening parameter of ellipsoid</span>
e2 = 2*f-f^2;       <span class="comment">%square of eccentricity of ellipsoid.</span>

lambda = atan2d(xyz(2),xyz(1));     <span class="comment">%Longitude (deg)</span>
p = sqrt(xyz(1)^2+xyz(2)^2);
r =sqrt(sum(xyz.^2));

phi_gd = asind(xyz(3)/r);   <span class="comment">%initial guess for geodetic latitude (deg)</span>
tolerance = 1e-8;
dif = 1;
<span class="keyword">while</span> dif &gt; tolerance <span class="comment">%iterate until delta is small</span>

    C = R/sqrt(1-e2*sind(phi_gd)^2); <span class="comment">%Radius of curvature in the meridian</span>
    tan_phi_gd = (xyz(3)+C*e2*sind(phi_gd))/p;
    phi_gd_new = atand(tan_phi_gd);   <span class="comment">%Geodetic latitude (deg)</span>
    dif = abs(phi_gd_new - phi_gd);      <span class="comment">%difference between guess and new</span>
    phi_gd = phi_gd_new;            <span class="comment">%set old to new</span>
<span class="keyword">end</span>

h = p/cosd(phi_gd)-C;       <span class="comment">%ellipsoidal height (meters) above surface</span>
lat = phi_gd;               <span class="comment">%latitude (deg)</span>
lon = lambda;               <span class="comment">%longitude (deg)</span>

<span class="keyword">end</span>

<span class="comment">% Problem 2 function</span>
<span class="keyword">function</span> A = ECEF2ENU(lat,lon)
    lam = lon;
    phi = lat;
    a1 = [1,0,0;<span class="keyword">...</span>
        0,sind(phi),cosd(phi);<span class="keyword">...</span>
        0,-cosd(phi),sind(phi)];
    a2 = [-sind(lam),cosd(lam),0;-cosd(lam),-sind(lam),0;0,0,1];
    A = a1*a2;
<span class="keyword">end</span>

<span class="comment">%Problem 3 function</span>
<span class="keyword">function</span> LOS_ENU = compute_LOS_ENU(nistECEF,satECEF)

<span class="comment">%a) compute the vector pointing from NIST_ecef location to satellite</span>
    elos_ECEF = satECEF - nistECEF;  <span class="comment">%line of site vector from NIST_ecef to satellite</span>

<span class="comment">%b) normalize it to a unit vector</span>
    elos_norm = elos_ECEF/sqrt(sum(elos_ECEF.^2));

<span class="comment">%c) transform the unit vector from ECEF to ENU</span>
    [lat,lon,h] = ECEF2llh(nistECEF); <span class="comment">%get latitude and longitude of NIST_ecef</span>
    ENU_matrix = ECEF2ENU(lat,lon);

    LOS_ENU = ENU_matrix*elos_norm.';
<span class="keyword">end</span>

<span class="comment">%Problem 4 function</span>
<span class="keyword">function</span> [az,el,range] = compute_azelrange(nistECEF,satECEF)
    los_enu = compute_LOS_ENU(nistECEF,satECEF);
    range = sqrt(sum((nistECEF-satECEF).^2));   <span class="comment">%distance btwn NIST_ecef and sat</span>
    r = sqrt(sum(los_enu.^2));                  <span class="comment">%always 1? weird</span>
    az = atan2d(round(los_enu(1),5),round(los_enu(2),5));   <span class="comment">%azimuth (deg)</span>
    el = asind(los_enu(3)/r);                   <span class="comment">%elevation (deg)</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% HW4

clc;clear;close all;

% Date = October 5, 2020

%% Define necessary variables
c   = 2.99792458e8;    % GPS acceptd speed of light, m/s

%% 1) Determine the name of the full broadcast ephemeris file (Rinex V2) for September 1, 2020.
% fname = "brdc2450.20n";
fname = "nist2450.20n"; %Either the broadcast data from NIST or brdc work.

%% 2) Use the function read_clean_GPSbroadcast.m (or a similar function you find elsewhere or write
% yourself) to load the ephemeris data into a numerical array.

seconds_in_day = 60*60*24;
tow = seconds_in_day * 2; % Because we are on Tuesday

[gps_ephem,ionoparams] = read_clean_GPSbroadcast(fname,true);

%% 3) Write a function broadcast_eph2pos to compute the position of a GPS satellite based on the ephemeris data, for
% a specified set of times. 
t = [0:1:24*60*2]*30+172800;  %Time of week in seconds with 30 sec spacing 
% t = [0:1:24*60]*60+172800;  %Time of week in seconds with 30 sec spacing 
WN = 2121*ones(size(t)); % WN = 73*ones(size(t));
T_in = [WN;t].';            %[nx2] 
gpsposcheck = zeros(32,3);

PRN = gps_ephem(:,1); % Grab all the prn values from the ephemeris file
num_sat = length(PRN); % Obtain the number of satellites we're interested in

% Grab the position of all of the satellites in the ephemeris file
for kk = 1:num_sat
    % Use our broadcast_eph2pos file to grab the position of the satellite
    [health,pos] = broadcast_eph2pos(gps_ephem,T_in,PRN(kk));
    POS_ecef(:,:,kk) = pos/1000;     %n x 3 x num_sat
    
    % This is to compare to the gpspos text file!
    if kk <= 30
        gpsposcheck(kk,:) = POS_ecef(1,:,kk);
    end
end

%% 4) Choose one or two satellites (PRN’s) to study in detail. Using the broadcast2pos function (or similar code
% you wrote yourself) from HW3, plot the ECEF coordinates computed based on the almanac for these satellites
% at an interval of 30 seconds over the entire day. On the x-axis show the time in hours of the day (0-24 hours).
% On the same graph, plot the ECEF coordinates computed using your new broadcast_eph2pos function for
% the same times. Compare and discuss the results, using a plot of the differences between them, if that is helpful.

prn_sat1 = 1; % I picked PRNs 1 and 2
prn_sat2 = 2;

% First we filter out the PRNs we want from our ephemeris data
ephem_PRN1 = find(PRN==prn_sat1);
ephem_PRN2 = find(PRN==prn_sat2);

ephem_PRN1_pos = POS_ecef(:,:,ephem_PRN1); % Now we can plot the ephemeris positions for satellites with PRN1
ephem_PRN2_pos = POS_ecef(:,:,ephem_PRN2); % Now we can plot the ephemeris positions for satellites with PRN2

% Now we grab the positions using YUMA file
[alm,alm_cellarray] = read_GPSyuma('Data/YUMA245.alm',2);
yuma_PRN = alm(:,1);
yuma_num_sat = length(PRN);
for kk = 1:num_sat
    [yuma_health,yuma_pos] = broadcast2pos(alm,T_in,PRN(kk));
    yumaPOS_ecef(:,:,kk) = yuma_pos/1000;     %n x 3 x num_sat
end

yuma_PRN1 = find(yuma_PRN==prn_sat1);
yuma_PRN2 = find(yuma_PRN==prn_sat2);

yuma_PRN1_pos = yumaPOS_ecef(:,:,yuma_PRN1); % Now we can plot the yuma positions for satellites with PRN1
yuma_PRN2_pos = yumaPOS_ecef(:,:,yuma_PRN2); % Now we can plot the yuma positions for satellites with PRN2

% Now we do our plots... let's just play with the first PRN1 position
time = [0:1:24*60*2]*30/3600;  %Time of week in seconds with 30 sec spacing 
time = time';

figure; hold on; grid on
plot(time, squeeze(ephem_PRN1_pos(:,1,1)), 'LineWidth', 2) % Plot 1st ecef coord
plot(time, squeeze(ephem_PRN1_pos(:,2,1)), 'LineWidth', 2) % Plot 2nd ecef coord
plot(time, squeeze(ephem_PRN1_pos(:,3,1)), 'LineWidth', 2) % Plot 3rd ecef coord
plot(time, yuma_PRN1_pos(:,1), 'Linestyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2) % Plot 1st ecef coord
plot(time, yuma_PRN1_pos(:,2), 'Linestyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2) % Plot 2nd ecef coord
plot(time, yuma_PRN1_pos(:,3), 'Linestyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2) % Plot 3rd ecef coord
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Coordinate [km]')
legend({'Ephemeris Coord 1', 'Ephemeris Coord 2', 'Ephemeris Coord 3', 'YUMA Coord 1', 'YUMA Coord 2', 'YUMA Coord 3'}, 'Location','southwest')
title({['ECEF Coords PRN1'], ['Yuma and Ephemeris Comparison']})

figure; hold on; grid on
plot(time, squeeze(ephem_PRN2_pos(:,1,1)), 'LineWidth', 2) % Plot 1st ecef coord
plot(time, squeeze(ephem_PRN2_pos(:,2,1)), 'LineWidth', 2) % Plot 2nd ecef coord
plot(time, squeeze(ephem_PRN2_pos(:,3,1)), 'LineWidth', 2) % Plot 3rd ecef coord
plot(time, yuma_PRN2_pos(:,1), 'Linestyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2) % Plot 1st ecef coord
plot(time, yuma_PRN2_pos(:,2), 'Linestyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2) % Plot 2nd ecef coord
plot(time, yuma_PRN2_pos(:,3), 'Linestyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2) % Plot 3rd ecef coord
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Coordinate [km]')
legend({'Ephemeris Coord 1', 'Ephemeris Coord 2', 'Ephemeris Coord 3', 'YUMA Coord 1', 'YUMA Coord 2', 'YUMA Coord 3'}, 'Location','southwest')
title({['ECEF Coords PRN2'], ['Yuma and Ephemeris Comparison']})

% Now we do diff plots of PRN1 because that maeks more sense to me
diff1 = reshape(ephem_PRN1_pos(:,1,:) - yuma_PRN1_pos(:,1), [length(t), length(ephem_PRN1)]);
diff2 = reshape(ephem_PRN1_pos(:,2,:) - yuma_PRN1_pos(:,2), [length(t), length(ephem_PRN1)]);
diff3 = reshape(ephem_PRN1_pos(:,3,:) - yuma_PRN1_pos(:,3), [length(t), length(ephem_PRN1)]);

f=figure; hold on; grid on
plot(time, diff1(:,1), 'LineWidth', 2)
plot(time, diff2(:,1), 'LineWidth', 2)
plot(time, diff3(:,1), 'LineWidth', 2)
title({['Difference Between ECEF Coords [km]'],['PRN1']})
xlabel('Time [hours]')
ylabel('Difference [km]')
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Difference [km]')
legend({'ECEF Coord 1', 'ECEF Coord 2', 'ECEF Coord 3'},'Location','northwest')

% Now we do diff plots of PRN2
diff1 = reshape(ephem_PRN2_pos(:,1,:) - yuma_PRN2_pos(:,1), [length(t), length(ephem_PRN2)]);
diff2 = reshape(ephem_PRN2_pos(:,2,:) - yuma_PRN2_pos(:,2), [length(t), length(ephem_PRN2)]);
diff3 = reshape(ephem_PRN2_pos(:,3,:) - yuma_PRN2_pos(:,3), [length(t), length(ephem_PRN2)]);

f=figure; hold on; grid on
plot(time, diff1(:,1), 'LineWidth', 2)
plot(time, diff2(:,1), 'LineWidth', 2)
plot(time, diff3(:,1), 'LineWidth', 2)
title({['Difference Between ECEF Coords [km]'],['PRN2']})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Difference [km]')
legend({'ECEF Coord 1', 'ECEF Coord 2', 'ECEF Coord 3'},'Location','northeast')

%% 5) Using the compute_azelrange function you wrote in HW3, find the range, azimuth, and elevation from
% your satellite(s) to the NIST IGS Site for the entire day. Use the GPS positions you calculated using your new
% function based on the ephemeris, not the almanac. Plot each of these versus time in hours of the day.
NIST_ecef = [-1288398 -4721697 4078625]; %ECEF coordinates in meters x y z
nistECEF = [NIST_ecef];
num_NIST_ecef = size(nistECEF,1);    %number of NIST_ecef locations

num_time = size(t,2);
for kk = 1:2
    [health,pos] = broadcast_eph2pos(gps_ephem,T_in,kk);
    for tt = 1:num_time
        [azt(tt,kk,1),elt(tt,kk,1),ranget(tt,kk,1)] = compute_azelrange(NIST_ecef,pos(tt,:));
    end
    if kk == 1
        satPos1 = pos;
    else
        satPos2 = pos;
    end
end
 
% Plot Azimuth for Problem 5
f=figure; hold on; grid on
plot(time, azt(:,ephem_PRN1(1)), 'LineWidth', 2)
plot(time, azt(:,ephem_PRN2(1)), 'LineWidth', 2)
title({['Azimuth [Degrees]']})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Azimuth [Degrees]')
legend({'PRN1', 'PRN2'})

% Plot Elevation for Problem 5
f=figure; hold on; grid on
plot(time, elt(:,1), 'LineWidth', 2)
plot(time, elt(:,2), 'LineWidth', 2)
title({['Elevation [Degrees]']})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Elevation [Degrees]')
legend({'PRN1', 'PRN2'})

% Plot Range for Problem 5
f=figure; hold on; grid on
plot(time, ranget(:,1), 'LineWidth', 2)
plot(time, ranget(:,2), 'LineWidth', 2)
title({['Range [Meters]']})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Range [Meters]')
legend({'PRN1', 'PRN2'})

%% 6) Now recompute the range accounting for the signal travel time and coordinate frame rotation as described in the
% attachment. Add this updated range to the previous range plot and compare the results. What is the largest
% difference you found?

% COMPUTING THE EXPECTED RANGE:
% The expected range of interest is the distance between the position of the GPS satellite at the time of transmission
% (Tt) and the GPS receiving antenna at the time of reception (Tr). To compute this distance, both positions must be
% represented in the same coordinate frame - we use the ECEF coordinate frame at the time of reception (Tr).
satECEF = satPos1; % We'll do this for just one sattelite

TOL = 1e-8;

not_converged = true;

satECEF = satPos1;
% Choose one satellite 
while not_converged
    % 1) Compute the GPS satellite poisition in ECEF at Tr based on the
    % broadcast ephemeris
    
    % Compute GPS satellite position at recieved time for rough idea of range
    % to satellite using an assumed location of reciever
    Tr = ranget(:,1) / c; % Calc for first satellite
    
    % 2) Use an a priori value for the receiver coordinates (RX) to find geometric range R = |rGPS – rRX|
    for tt = 1:num_time    
        [~, ~, rGPS] = ECEF2llh(satECEF(tt,:));
        [~, ~,  rRx] = ECEF2llh(nistECEF); % assumed location of reciever is location for NIST
        R(tt) = abs(rGPS - rRx);
    
    end
    % 3) Compute the time of transmission: Tt = Tr – R/c (use the real speed of
    % light, NOT 3e8), it's usually 70-100 milliseconds
    Tt = Tr  - R'/c;
    
    % 4) Compute the satellite position at Tt in ECEF at Tt based on the broadcast ephemeris.
    newt = Tt*30+172800;  %Time of week in seconds with 30 sec spacing
    newT_in = [WN;newt'].';
    [health, new_pos] = broadcast_eph2pos(gps_ephem, newT_in, PRN);
    
    % 5) Rotate the satellite position to ECEF at Tr. (wE is the rotation rate of the Earth)
    w_e = 7.2921151467e-5; % earth rotation rate [rad / sec]
    for kk = 1
        for tt = 1:num_time
            
            phi = w_e * (Tr(tt, kk)-Tt(tt, kk)); % amount of rotation the earth moved during time of transmission
            cosPhi = cos(phi);
            sinPhi = sin(phi);
            
            rotation_matrix = [cosPhi, sinPhi, 0; -sinPhi, cosPhi, 0; 0, 0, 1];
            rot_pos(tt ,: , kk) = (rotation_matrix * new_pos(tt,:).')';
            
        end
    end
    
    % 6) Compute a new geometric range using this position for rGPS, R = |rGPS – rRX|
    for jj = 1:num_NIST_ecef
        NIST_ecef = nistECEF(jj,:);      %grab the appropriate NIST_ecef location
        num_time = size(t,2);
        for kk = 1
            for tt = 1:num_time
                satECEF = rot_pos(tt,:,kk);
                [~,~,new_ranget(tt,kk,jj)] = compute_azelrange(NIST_ecef,satECEF);
            end
        end
    end
    
    % 7) Repeat steps 3-6 until convergence. (If it takes more than two iterations, something is wrong).
    sprintf('Tolerance: %0.5g',abs(new_ranget(1,1) - ranget(1,1)))
    if abs(ranget(1,1) - new_ranget(1,1)) < TOL 
        not_converged = false; % Go back to beginning :)
    end
    ranget = new_ranget;

end

% Plot Range
figure
hold on; grid on;
plot(time, ranget)
title({['Problem 6 Range [Meters]']})
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Range [Meters]')
legend({'PRN1', 'PRN2'})

%% 7. Download the NIST rinex observation file for September 1, 2020. Use the function read_rinex_obs8 or
% another version that you find or write yourself to read the RINEX file and extract all of the measured C1 and P2
% pseudoranges for the satellite you chose. Plot these pseudoranges versus time in hours of the day.
fname = "DATA\nist2450.20o";

prn1_rdata = read_rinex_obs8(fname, [1]); % Grab PRN1 data
prn2_rdata = read_rinex_obs8(fname, [2]); % Grab PRN2 data

% Grab C1 and P2 for PRN1 and Plot
prn1_C1 = prn1_rdata.data(:,4);
prn1_P2 = prn1_rdata.data(:,8);

%% Plot C1 and P2 for PRN1
figure; hold on; grid on % Create figure
plot(1:1:length(prn1_C1), prn1_C1, 'LineWidth', 2)
plot(1:1:length(prn1_P2), prn1_P2, 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2)
% Make plot pretty
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Pseudoranges [km]')
legend({'C1', 'P2'})
title({['Pseudoranges C1 and P2'], ['PRN1']})

%% Grab C1 and P2 for PRN1 and Plot
prn2_C1 = prn2_rdata.data(:,4);
prn2_P2 = prn1_rdata.data(:,8);

% Plot C1 and P2 for PRN2
figure; hold on; grid on
plot(1:1:length(prn2_C1), prn2_C1, 'LineWidth', 2)
plot(1:1:length(prn2_P2), prn2_P2, 'REPLACE_WITH_DASH_DASH', 'LineWidth', 2)
xlim([time(1), time(end)])
xticks([0:3:24])
xlabel('Time [hours]')
ylabel('Pseudoranges [m]')
legend({'C1', 'P2'})
title({['Pseudoranges C1 and P2'], ['PRN2']})

%% 8) Describe the visibility results for the three locations.
% Compare the measured pseudoranges to your predicted range. Briefly explain what might be the source of any
% differences between them. (To do this part, create a time vector from the observations and compute the
% predicted range for those times.)
% The range calculated in problem 6 has the same order of magnitude as the
% pseudoranges. This could be becausse sp3 files are re-calculated every epoch and it
% takes a much longer time to calculate these but they are more accurate.

%% Functions
% Problem 1 function
function [lat,lon,h] = ECEF2llh(xyz)
R = 6378.137e3;             %SemiMajor axis of ellipsoid (meters)
f = 1/298.257223563;% flattening parameter of ellipsoid
e2 = 2*f-f^2;       %square of eccentricity of ellipsoid. 

lambda = atan2d(xyz(2),xyz(1));     %Longitude (deg)
p = sqrt(xyz(1)^2+xyz(2)^2);        
r =sqrt(sum(xyz.^2));

phi_gd = asind(xyz(3)/r);   %initial guess for geodetic latitude (deg)
tolerance = 1e-8;    
dif = 1;            
while dif > tolerance %iterate until delta is small
    
    C = R/sqrt(1-e2*sind(phi_gd)^2); %Radius of curvature in the meridian
    tan_phi_gd = (xyz(3)+C*e2*sind(phi_gd))/p;
    phi_gd_new = atand(tan_phi_gd);   %Geodetic latitude (deg)
    dif = abs(phi_gd_new - phi_gd);      %difference between guess and new
    phi_gd = phi_gd_new;            %set old to new
end

h = p/cosd(phi_gd)-C;       %ellipsoidal height (meters) above surface
lat = phi_gd;               %latitude (deg)
lon = lambda;               %longitude (deg)

end

% Problem 2 function
function A = ECEF2ENU(lat,lon)
    lam = lon;
    phi = lat;
    a1 = [1,0,0;...
        0,sind(phi),cosd(phi);...
        0,-cosd(phi),sind(phi)];
    a2 = [-sind(lam),cosd(lam),0;-cosd(lam),-sind(lam),0;0,0,1];
    A = a1*a2;
end

%Problem 3 function
function LOS_ENU = compute_LOS_ENU(nistECEF,satECEF)

%a) compute the vector pointing from NIST_ecef location to satellite
    elos_ECEF = satECEF - nistECEF;  %line of site vector from NIST_ecef to satellite
    
%b) normalize it to a unit vector
    elos_norm = elos_ECEF/sqrt(sum(elos_ECEF.^2));
    
%c) transform the unit vector from ECEF to ENU 
    [lat,lon,h] = ECEF2llh(nistECEF); %get latitude and longitude of NIST_ecef
    ENU_matrix = ECEF2ENU(lat,lon);
    
    LOS_ENU = ENU_matrix*elos_norm.';
end

%Problem 4 function
function [az,el,range] = compute_azelrange(nistECEF,satECEF)
    los_enu = compute_LOS_ENU(nistECEF,satECEF);
    range = sqrt(sum((nistECEF-satECEF).^2));   %distance btwn NIST_ecef and sat
    r = sqrt(sum(los_enu.^2));                  %always 1? weird
    az = atan2d(round(los_enu(1),5),round(los_enu(2),5));   %azimuth (deg)
    el = asind(los_enu(3)/r);                   %elevation (deg)
end

##### SOURCE END #####
--></body></html>